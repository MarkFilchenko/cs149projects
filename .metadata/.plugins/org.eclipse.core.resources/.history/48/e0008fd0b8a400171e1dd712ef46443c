import java.util.*;

public class ShortestRemainingTime {

	private PriorityQueue<Job> waitingJobs;//sort by runtime
	private PriorityQueue<Job> workingJobs;//sort by runtime
	private Job jobBeingWorked;

	int timer = 0;



	static Comparator<Job> compareByArrivalTime = new Comparator<Job>(){
		@Override
		public int compare(Job o1, Job o2) {
			// TODO Auto-generated method stub

			float oneComparison = o1.arrivalTime;
			float twoComparison = o2.arrivalTime;

			if(oneComparison < twoComparison)
				return -1;
			if(oneComparison > twoComparison)
				return 1;
			return 0;
		}

	};
	private static Comparator<Job> compareByRemainingTime = new Comparator<Job>(){
		@Override
		public int compare(Job o1, Job o2) {
			// TODO Auto-generated method stub

			float oneComparison = o1.getTimeLeft();
			float twoComparison = o2.getTimeLeft();

			if(oneComparison < twoComparison)
				return -1;
			if(oneComparison > twoComparison)
				return 1;
			return 0;
		}

	};


	/////////Constructors//////////////////////////////////

	public ShortestRemainingTime(){                     
		waitingJobs = new PriorityQueue<>(compareByRemainingTime);
		workingJobs = new PriorityQueue<Job>(compareByRemainingTime);
	}



	private Queue<Job> doJobs(PriorityQueue<Job> queue){
		Queue<Job> newQueue = new LinkedList<Job>();

		while(!queue.isEmpty()){
			queue.peek().doJob();
			if(queue.peek().isComplete())
				newQueue.add(queue.poll());
		}
		//have a queue by arrival time
		//have a queue by expected run time

		//take arrival queue and put in running 
		//queue start the first one,
		//work on running queue until timer reaches
		//arrival queues next arrival time
		//if smaller arrival time, compare against waiting queue
		//if smaller, arrival queue to working queue
		//else, arrival queue to waiting
		//else add to waiting queue

		//loop until new queue is the size of jobs

		return newQueue;
			 
	}

	public static void main(String[] args){
		Random r = new Random();
		PriorityQueue<Job> arg = Job.JOBS();
		ShortestRemainingTime str = new ShortestRemainingTime();
		Queue q = str.doJobs(arg);
		
		System.out.print(q.peek().getTimeLeft());
		//rand.nextInt((max - min) + 1) + min;
	}

}